/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable
// @generated from protobuf file "user.proto" (package "user", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message user.EmptyRequest
 */
export interface EmptyRequest {
}
/**
 * @generated from protobuf message user.EmptyReply
 */
export interface EmptyReply {
}
/**
 * @generated from protobuf message user.UserCreateRequest
 */
export interface UserCreateRequest {
    /**
     * @generated from protobuf field: string user_name = 1;
     */
    userName: string;
    /**
     * @generated from protobuf field: string email = 2;
     */
    email: string;
    /**
     * @generated from protobuf field: string password = 3;
     */
    password: string;
}
/**
 * @generated from protobuf message user.UserCreateErrors
 */
export interface UserCreateErrors {
    /**
     * @generated from protobuf field: repeated string user_name = 1;
     */
    userName: string[];
    /**
     * @generated from protobuf field: repeated string email = 2;
     */
    email: string[];
    /**
     * @generated from protobuf field: repeated string password = 3;
     */
    password: string[];
    /**
     * @generated from protobuf field: repeated string other = 4;
     */
    other: string[];
}
/**
 * @generated from protobuf message user.UserCreateReply
 */
export interface UserCreateReply {
    /**
     * @generated from protobuf field: bool succeeded = 1;
     */
    succeeded: boolean;
    /**
     * @generated from protobuf field: user.UserCreateErrors errors = 2;
     */
    errors?: UserCreateErrors;
    /**
     * @generated from protobuf field: user.UserReply user = 3;
     */
    user?: UserReply;
}
/**
 * @generated from protobuf message user.UserFindRequest
 */
export interface UserFindRequest {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
}
/**
 * @generated from protobuf message user.UserReply
 */
export interface UserReply {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string user_name = 2;
     */
    userName: string;
    /**
     * @generated from protobuf field: string email = 3;
     */
    email: string;
}
/**
 * @generated from protobuf message user.UsersReply
 */
export interface UsersReply {
    /**
     * @generated from protobuf field: repeated user.UserReply users = 1;
     */
    users: UserReply[];
}
/**
 * @generated from protobuf message user.UserUpdateErrors
 */
export interface UserUpdateErrors {
    /**
     * @generated from protobuf field: repeated string user_id = 1;
     */
    userId: string[];
    /**
     * @generated from protobuf field: repeated string user_name = 2;
     */
    userName: string[];
    /**
     * @generated from protobuf field: repeated string email = 3;
     */
    email: string[];
    /**
     * @generated from protobuf field: repeated string old_password = 4;
     */
    oldPassword: string[];
    /**
     * @generated from protobuf field: repeated string new_password = 5;
     */
    newPassword: string[];
}
/**
 * @generated from protobuf message user.UserUpdateRequest
 */
export interface UserUpdateRequest {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string user_name = 2;
     */
    userName: string;
    /**
     * @generated from protobuf field: string email = 3;
     */
    email: string;
    /**
     * @generated from protobuf field: string old_password = 4;
     */
    oldPassword: string;
    /**
     * @generated from protobuf field: string new_password = 5;
     */
    newPassword: string;
}
/**
 * @generated from protobuf message user.UserUpdateReply
 */
export interface UserUpdateReply {
    /**
     * @generated from protobuf field: bool succeeded = 1;
     */
    succeeded: boolean;
    /**
     * @generated from protobuf field: user.UserUpdateErrors errors = 2;
     */
    errors?: UserUpdateErrors;
    /**
     * @generated from protobuf field: user.UserReply user = 3;
     */
    user?: UserReply;
}
// @generated message type with reflection information, may provide speed optimized methods
class EmptyRequest$Type extends MessageType<EmptyRequest> {
    constructor() {
        super("user.EmptyRequest", []);
    }
    create(value?: PartialMessage<EmptyRequest>): EmptyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EmptyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmptyRequest): EmptyRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: EmptyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.EmptyRequest
 */
export const EmptyRequest = new EmptyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmptyReply$Type extends MessageType<EmptyReply> {
    constructor() {
        super("user.EmptyReply", []);
    }
    create(value?: PartialMessage<EmptyReply>): EmptyReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EmptyReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmptyReply): EmptyReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: EmptyReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.EmptyReply
 */
export const EmptyReply = new EmptyReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserCreateRequest$Type extends MessageType<UserCreateRequest> {
    constructor() {
        super("user.UserCreateRequest", [
            { no: 1, name: "user_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserCreateRequest>): UserCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userName = "";
        message.email = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<UserCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserCreateRequest): UserCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_name */ 1:
                    message.userName = reader.string();
                    break;
                case /* string email */ 2:
                    message.email = reader.string();
                    break;
                case /* string password */ 3:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_name = 1; */
        if (message.userName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userName);
        /* string email = 2; */
        if (message.email !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.email);
        /* string password = 3; */
        if (message.password !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.UserCreateRequest
 */
export const UserCreateRequest = new UserCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserCreateErrors$Type extends MessageType<UserCreateErrors> {
    constructor() {
        super("user.UserCreateErrors", [
            { no: 1, name: "user_name", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "email", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "password", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "other", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserCreateErrors>): UserCreateErrors {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userName = [];
        message.email = [];
        message.password = [];
        message.other = [];
        if (value !== undefined)
            reflectionMergePartial<UserCreateErrors>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserCreateErrors): UserCreateErrors {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string user_name */ 1:
                    message.userName.push(reader.string());
                    break;
                case /* repeated string email */ 2:
                    message.email.push(reader.string());
                    break;
                case /* repeated string password */ 3:
                    message.password.push(reader.string());
                    break;
                case /* repeated string other */ 4:
                    message.other.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserCreateErrors, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string user_name = 1; */
        for (let i = 0; i < message.userName.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.userName[i]);
        /* repeated string email = 2; */
        for (let i = 0; i < message.email.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.email[i]);
        /* repeated string password = 3; */
        for (let i = 0; i < message.password.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.password[i]);
        /* repeated string other = 4; */
        for (let i = 0; i < message.other.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.other[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.UserCreateErrors
 */
export const UserCreateErrors = new UserCreateErrors$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserCreateReply$Type extends MessageType<UserCreateReply> {
    constructor() {
        super("user.UserCreateReply", [
            { no: 1, name: "succeeded", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "errors", kind: "message", T: () => UserCreateErrors },
            { no: 3, name: "user", kind: "message", T: () => UserReply }
        ]);
    }
    create(value?: PartialMessage<UserCreateReply>): UserCreateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.succeeded = false;
        if (value !== undefined)
            reflectionMergePartial<UserCreateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserCreateReply): UserCreateReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool succeeded */ 1:
                    message.succeeded = reader.bool();
                    break;
                case /* user.UserCreateErrors errors */ 2:
                    message.errors = UserCreateErrors.internalBinaryRead(reader, reader.uint32(), options, message.errors);
                    break;
                case /* user.UserReply user */ 3:
                    message.user = UserReply.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserCreateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool succeeded = 1; */
        if (message.succeeded !== false)
            writer.tag(1, WireType.Varint).bool(message.succeeded);
        /* user.UserCreateErrors errors = 2; */
        if (message.errors)
            UserCreateErrors.internalBinaryWrite(message.errors, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* user.UserReply user = 3; */
        if (message.user)
            UserReply.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.UserCreateReply
 */
export const UserCreateReply = new UserCreateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserFindRequest$Type extends MessageType<UserFindRequest> {
    constructor() {
        super("user.UserFindRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserFindRequest>): UserFindRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<UserFindRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserFindRequest): UserFindRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserFindRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.UserFindRequest
 */
export const UserFindRequest = new UserFindRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserReply$Type extends MessageType<UserReply> {
    constructor() {
        super("user.UserReply", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserReply>): UserReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.userName = "";
        message.email = "";
        if (value !== undefined)
            reflectionMergePartial<UserReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserReply): UserReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string user_name */ 2:
                    message.userName = reader.string();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string user_name = 2; */
        if (message.userName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userName);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.UserReply
 */
export const UserReply = new UserReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UsersReply$Type extends MessageType<UsersReply> {
    constructor() {
        super("user.UsersReply", [
            { no: 1, name: "users", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UserReply }
        ]);
    }
    create(value?: PartialMessage<UsersReply>): UsersReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.users = [];
        if (value !== undefined)
            reflectionMergePartial<UsersReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UsersReply): UsersReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated user.UserReply users */ 1:
                    message.users.push(UserReply.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UsersReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated user.UserReply users = 1; */
        for (let i = 0; i < message.users.length; i++)
            UserReply.internalBinaryWrite(message.users[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.UsersReply
 */
export const UsersReply = new UsersReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserUpdateErrors$Type extends MessageType<UserUpdateErrors> {
    constructor() {
        super("user.UserUpdateErrors", [
            { no: 1, name: "user_id", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_name", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "old_password", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "new_password", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserUpdateErrors>): UserUpdateErrors {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = [];
        message.userName = [];
        message.email = [];
        message.oldPassword = [];
        message.newPassword = [];
        if (value !== undefined)
            reflectionMergePartial<UserUpdateErrors>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserUpdateErrors): UserUpdateErrors {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string user_id */ 1:
                    message.userId.push(reader.string());
                    break;
                case /* repeated string user_name */ 2:
                    message.userName.push(reader.string());
                    break;
                case /* repeated string email */ 3:
                    message.email.push(reader.string());
                    break;
                case /* repeated string old_password */ 4:
                    message.oldPassword.push(reader.string());
                    break;
                case /* repeated string new_password */ 5:
                    message.newPassword.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserUpdateErrors, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string user_id = 1; */
        for (let i = 0; i < message.userId.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.userId[i]);
        /* repeated string user_name = 2; */
        for (let i = 0; i < message.userName.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.userName[i]);
        /* repeated string email = 3; */
        for (let i = 0; i < message.email.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.email[i]);
        /* repeated string old_password = 4; */
        for (let i = 0; i < message.oldPassword.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.oldPassword[i]);
        /* repeated string new_password = 5; */
        for (let i = 0; i < message.newPassword.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.newPassword[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.UserUpdateErrors
 */
export const UserUpdateErrors = new UserUpdateErrors$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserUpdateRequest$Type extends MessageType<UserUpdateRequest> {
    constructor() {
        super("user.UserUpdateRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "old_password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "new_password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserUpdateRequest>): UserUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.userName = "";
        message.email = "";
        message.oldPassword = "";
        message.newPassword = "";
        if (value !== undefined)
            reflectionMergePartial<UserUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserUpdateRequest): UserUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string user_name */ 2:
                    message.userName = reader.string();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                case /* string old_password */ 4:
                    message.oldPassword = reader.string();
                    break;
                case /* string new_password */ 5:
                    message.newPassword = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string user_name = 2; */
        if (message.userName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userName);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        /* string old_password = 4; */
        if (message.oldPassword !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.oldPassword);
        /* string new_password = 5; */
        if (message.newPassword !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.newPassword);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.UserUpdateRequest
 */
export const UserUpdateRequest = new UserUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserUpdateReply$Type extends MessageType<UserUpdateReply> {
    constructor() {
        super("user.UserUpdateReply", [
            { no: 1, name: "succeeded", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "errors", kind: "message", T: () => UserUpdateErrors },
            { no: 3, name: "user", kind: "message", T: () => UserReply }
        ]);
    }
    create(value?: PartialMessage<UserUpdateReply>): UserUpdateReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.succeeded = false;
        if (value !== undefined)
            reflectionMergePartial<UserUpdateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserUpdateReply): UserUpdateReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool succeeded */ 1:
                    message.succeeded = reader.bool();
                    break;
                case /* user.UserUpdateErrors errors */ 2:
                    message.errors = UserUpdateErrors.internalBinaryRead(reader, reader.uint32(), options, message.errors);
                    break;
                case /* user.UserReply user */ 3:
                    message.user = UserReply.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserUpdateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool succeeded = 1; */
        if (message.succeeded !== false)
            writer.tag(1, WireType.Varint).bool(message.succeeded);
        /* user.UserUpdateErrors errors = 2; */
        if (message.errors)
            UserUpdateErrors.internalBinaryWrite(message.errors, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* user.UserReply user = 3; */
        if (message.user)
            UserReply.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.UserUpdateReply
 */
export const UserUpdateReply = new UserUpdateReply$Type();
/**
 * @generated ServiceType for protobuf service user.Users
 */
export const Users = new ServiceType("user.Users", [
    { name: "GetAll", options: {}, I: EmptyRequest, O: UsersReply },
    { name: "GetById", options: {}, I: UserFindRequest, O: UserReply },
    { name: "Create", options: {}, I: UserCreateRequest, O: UserCreateReply },
    { name: "Update", options: {}, I: UserUpdateRequest, O: UserUpdateReply },
    { name: "Delete", options: {}, I: UserFindRequest, O: EmptyReply }
]);
